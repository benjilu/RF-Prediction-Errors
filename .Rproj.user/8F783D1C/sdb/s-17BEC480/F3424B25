{
    "collab_server" : "",
    "contents" : "#' Quantify random forest prediction error\n#'\n#' Estimates the conditional mean squared prediction errors and conditional\n#' prediction intervals of random forest predictions.\n#'\n#' Three possible sets of outputs are possible from this function depending\n#' on the user's arguments for \\code{alpha} and \\code{conservative}.\n#'\n#' The most minimal output is a list containing the random forest predictions of\n#' the test observations and the estimated conditional mean squared prediction\n#' errors associated with each. This can be obtained by setting \\code{alpha}\n#' to \\code{NA}.\n#'\n#' The second possible output is a list that includes, in addition to the\n#' random forest predictions and the estimated prediction errors, conditional\n#' prediction intervals for each test observation with level specified by\n#' \\code{alpha}. This can be obtained by setting \\code{alpha} to a numeric\n#' value and setting \\code{conservative} to \\code{FALSE}.\n#'\n#' The most extensive set of outputs includes, in addition to the above, a\n#' second set of prediction intervals generated by resolving ties in the\n#' empirical error distribution conservatively. Conservatively estimated\n#' prediction intervals may be desirable when the number of observations is\n#' relatively small. This output can be obtained by setting \\code{alpha} to a\n#' numeric value and setting \\code{conservative} to \\code{TRUE}.\n#'\n#' @param forest The random forest object being used for prediction.\n#' @param X.train A \\code{matrix} or \\code{data.frame} with the observations\n#'   that were used to train \\code{forest}; each row should be an observation,\n#'   and each column should be a predictor variable.\n#' @param X.test A \\code{matrix} or \\code{data.frame} with the observations to\n#'   be predicted; each row should be an observation, and each column should be\n#'   a predictor variable.\n#' @param alpha The type I error rate desired for the conditional prediction\n#'   intervals; set to \\code{NA} if no prediction intervals are desired.\n#'   Defauls to \\code{0.05}.\n#' @param conservative A \\code{logical} indicating whether a second set of\n#'   conditional prediction intervals should be estimated in which ties in the\n#'   empirical error distribution should be resolved conservatively or not.\n#'   Defaults to \\code{TRUE}.\n#'\n#' @return A list with the following possible elements, each in the form of a\n#'   vector, as described in the details section:\n#'\n#'   \\item{pred}{The random forest predictions of the test observations}\n#'   \\item{error}{The estimated conditional mean square prediction errors of\n#'   the random forest predictions}\n#'   \\item{lower}{The estimated lower bounds of the conditional prediction\n#'   intervals for the test observations}\n#'   \\item{upper}{The estimated upper bounds of the conditional prediction\n#'   intervals for the test observations}\n#'   \\item{lowerCons}{The conservatively estimated lower bounds of the\n#'   conditional prediction intervals for the test observations}\n#'   \\item{upperCons}{The conservatively estimated upper bounds of the\n#'   conditional prediction intervals for the test observations}\n#'\n#' @author Benjamin Lu \\code{<b.lu@berkeley.edu>}; Johanna Hardin \\code{<jo.hardin@pomona.edu>}\n#'\n#' @examples\n#' # load data\n#' data(airquality)\n#'\n#' # remove observations with missing predictor variable values\n#' airquality <- airquality[complete.cases(airquality), ]\n#'\n#' # get number of observations and the response column index\n#' n <- nrow(airquality)\n#' response.col <- 1\n#'\n#' # split data into training and test sets\n#' train.ind <- sample(1:n, n * 0.9, replace = FALSE)\n#' Xtrain <- airquality[train.ind, -response.col]\n#' Ytrain <- airquality[train.ind, response.col]\n#' Xtest <- airquality[-train.ind, -response.col]\n#' Ytest <- airquality[-train.ind, response.col]\n#'\n#' # fit random forest to the training data\n#' rf <- randomForest::randomForest(Xtrain, Ytrain, nodesize = 10, ntree = 500,\n#'                                  keep.inbag = TRUE)\n#'\n#' # get conditional mean squared prediction errors and prediction\n#' # intervals for the test observations\n#' test.preds <- quantForestError(rf, Xtrain, Xtest)\n#'\n#' # get the same as above but without the conservative prediction\n#' # intervals\n#' test.preds <- quantForestError(rf, Xtrain, Xtest, conservative = FALSE)\n#'\n#' # get just the mean squared prediction error estimates\n#' test.preds <- quantForestError(rf, Xtrain, Xtest, alpha = NA)\n#'\n#' @export\nquantForestError <- function(forest, X.train, X.test, alpha = 0.05, conservative = TRUE) {\n\n  # check forest, X.train, and X.test arguments for issues\n  checkForest(forest)\n  checkXtrainXtest(X.train, X.test)\n\n  # get terminal nodes of all observations\n  train.terminal.nodes <- attr(predict(forest, X.train, nodes = TRUE), \"nodes\")\n  test.terminal.nodes <- attr(predict(forest, X.test, nodes = TRUE), \"nodes\")\n\n  # get number of times each training observation appears in each tree\n  bag.count <- forest$inbag\n\n  # get the OOB prediction error of each training observation\n  oob.errors <- forest$y - forest$predicted\n\n  # get number of training and test observations\n  n.train <- nrow(X.train)\n  n.test <- nrow(X.test)\n\n  # get test observation predictions\n  test.preds <- predict(forest, X.test)\n\n  # get the terminal nodes of the training observations in the trees in which they are OOB\n  # (for all other trees, set the terminal node to be 0)\n  train.oob.terminal.nodes <- train.terminal.nodes * as.numeric(bag.count == 0)\n\n  # initialize dataframe\n  oob.weights <- data.frame(matrix(rep(NA, n.test * n.train), nrow = n.test))\n\n  # for each test observation\n  for (test.obs in 1:n.test) {\n\n    # get for each training observation the number of times it is an OOB cohabitant of the test observation and record it in the dataframe\n    oob.weights[test.obs, ] <- rowSums(sweep(train.oob.terminal.nodes, MARGIN = 2, test.terminal.nodes[test.obs, ], \"==\"))\n  }\n\n  # for each test observation, convert the number of times each training observation\n  # is an OOB cohabitant to the proportion of times each training observation is an\n  # OOB cohabitant\n  oob.weights <- oob.weights / rowSums(oob.weights)\n\n  # get the MSPE2 for each test observation\n  mspe2s <- as.matrix(oob.weights) %*% (oob.errors ^ 2)\n\n  # if the user requests prediction intervals with a certain alpha\n  if (!is.na(alpha)) {\n\n    # check the alpha argument and the conservative argument for issues\n    checkAlpha(alpha)\n    checkConservative(conservative)\n\n    # sort the OOB errors of the training observations\n    ordered.oob.errors <- sort(oob.errors, index.return = TRUE)\n\n    # sort the OOB weight assigned to each OOB error according to the value of\n    # the OOB error, in ascending order\n    ordered.oob.weights <- oob.weights[, ordered.oob.errors$ix]\n\n    # get the index of the training observation for which the cumulative sum of the OOB weights\n    # initially exceeds 0.025\n    lower.ind <- apply(ordered.oob.weights, 1, FUN = function(x) max(min(which(cumsum(x) >= alpha / 2)), 1))\n    # get the index of the training observation for which the cumulative sum of the OOB weights\n    # last remains below 0.975\n    upper.ind <- apply(ordered.oob.weights, 1, FUN = function(x) max(which(cumsum(x) <= 1 - (alpha / 2))))\n\n    # get the corresponding OOB errors and use them to construct prediction intervals\n    # for the test observations\n    lower.bounds <- test.preds + ordered.oob.errors$x[lower.ind]\n    upper.bounds <- test.preds + ordered.oob.errors$x[upper.ind]\n\n    # if the user requests conservative prediction intervals as well, compute them\n    if (conservative) {\n\n      # get the index of the training observation for which the cumulative sum of the OOB weights\n      # initially exceeds 0.025 (CONSERVATIVE)\n      con.lower.ind <- apply(ordered.oob.weights, 1, FUN = function(x) max(max(which(cumsum(x) <= alpha / 2)), 1))\n      # get the index of the training observation for which the cumulative sum of the OOB weights\n      # last remains below 0.975 (CONSERVATIVE)\n      con.upper.ind <- apply(ordered.oob.weights, 1, FUN = function(x) min(which(cumsum(x) >= 1 - (alpha / 2))))\n\n      # get the corresponding OOB errors and use them to construct prediction intervals\n      # for the test observations\n      con.lower.bounds <- test.preds + ordered.oob.errors$x[con.lower.ind]\n      con.upper.bounds <- test.preds + ordered.oob.errors$x[con.upper.ind]\n\n      # return the test predictions, prediction error, prediction intervals,\n      # and conservative prediction intervals\n      output <- list(pred = test.preds,\n                     error = as.vector(mspe2s),\n                     lower = lower.bounds,\n                     upper = upper.bounds,\n                     lowerCons = con.lower.bounds,\n                     upperCons = con.upper.bounds)\n\n    # else return the test predictions, prediction error, and prediction intervals\n    } else {\n      output <- list(pred = test.preds,\n                     error = as.vector(mspe2s),\n                     lower = lower.bounds,\n                     upper = upper.bounds)\n    }\n\n  # else return the test predictions and prediction error\n  } else {\n    output <- list(pred = test.preds,\n                   error = as.vector(mspe2s))\n  }\n\n  # return the test predictions, prediction error, and prediction intervals\n  return(output)\n}\n",
    "created" : 1564018359895.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2854972185",
    "id" : "F3424B25",
    "lastKnownWriteTime" : 1564016032,
    "last_content_update" : 1564016032,
    "path" : "~/Desktop/forestErrorPackage/RF-Prediction-Errors/R/quantforesterror.R",
    "project_path" : "R/quantforesterror.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}