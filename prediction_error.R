#####
# obtains and compiles data on where each training observation is, either across trees for which the observation is in bag or across trees for which the observation is out of bag
#
# forest (list): random forest trained on the data
# train.terminal.nodes (matrix): (num training observations) x (num trees) matrix, with (i,j) entry indicating the terminal node index of the i^th observation in the j^th tree
# bag.count (matrix): (num training observations) x (num trees) matrix, with (i,j) entry indicating the number of times the i^th observation is sampled for the j^th tree
# Y.train (vector): response values of the training observations
# type (character): "trainer" for data on in-bag training observations, "oob" for data on out-of-bag training observations
# RETURNS: dataframe of tree index, terminal node index, training index, tree prediction, and true response value for either in-bag or out-of-bag training observations
#
#####
get.forest.breakdown <- function(forest, train.terminal.nodes, bag.count, Y.train, type) {
  
  # if we are looking at in-bag observations (i.e., observations used to train the tree)
  if (type == "inbag") {
    
    # get the pairs of training and tree indices for which the observation is in bag
    indices <- which(bag.count > 0, arr.ind = TRUE)
    
    # initialize dataframe
    forest.breakdown <- data.frame(matrix(nrow = sum(apply(indices, 1, function(x) sum(bag.count[x[1], x[2]]))), ncol = 5))
    
    # initialize place marker
    place <- 1
    
    # fill in dataframe with tree index, terminal node index, training index, tree prediction, and true response value for the in-bag training observations
    invisible(
      apply(indices, 1, function(x) {
        forest.breakdown[place:(place + bag.count[x[1], x[2]] - 1), ] <<- t(replicate(bag.count[x[1], x[2]], c(x[2], train.terminal.nodes[x[1], x[2]], x[1], getTree(forest, k = x[2], TRUE)[train.terminal.nodes[x[1], x[2]], "prediction"], Y.train[x[1]])))
        place <<- place + bag.count[x[1], x[2]]
      }
      )
    )
    
    # else if we are looking at out-of-bag observations (i.e., observations not used to train the trees), do the same as above, except proceed if and only if the training observation is out of bag for the tree
  } else if (type == "oob") {
    
    indices <- which(bag.count == 0, arr.ind = TRUE)
    forest.breakdown <- data.frame(matrix(nrow = dim(indices)[1], ncol = 5))
    place <- 1
    invisible(
      apply(indices, 1, function(x) {
        forest.breakdown[place, ] <<- c(x[2], train.terminal.nodes[x[1], x[2]], x[1], getTree(forest, k = x[2], TRUE)[train.terminal.nodes[x[1], x[2]], "prediction"], Y.train[x[1]])
        place <<- place + 1
      }
      )
    )
  }
  
  # assign dataframe column names
  names(forest.breakdown) <- c("Tree", "Node", "Train.Index", "Node.Prediction", "Observed.Response")
  
  # return dataframe
  return(forest.breakdown)
}

#####
# calculates MSPE2
# MSPE2 is calculated for each test observation as follows:
# for each test observation, identify its out-of-bag cohabitants over all trees. for each cohabitant, identify the trees for which it is out of bag. then,
# average those trees' predictions of the cohabitant's response value. once this is done for each cohabitant, take the mean squared
# difference between each cohabitant's true response value and the prediction generated in the above manner. that value is MSE2
#
# cohabs (dataframe): dataframe of tree index, terminal node index, training index, tree prediction, and true response value for all out-of-bag cohabitants of the test observation
# n.oob.cohabs (double): number of out-of-bag cohabitants of the test observation (also the number of rows in cohabs)
# oobs (dataframe): dataframe of tree index, terminal node index, training index, tree prediction, and true response value for all out-of-bag training observations
# RETURNS: a double that serves as a variance estimate
#
#####
get.mspe2 <- function(cohabs, oobs) {
  
  n.oob.cohabs <- nrow(cohabs)
  
  # if there is at least one out-of-bag cohabitant
  if (n.oob.cohabs > 0) {
    
    # get a vector, the i^th element of which is the mean of the predictions of the response value of the test observation's i^th cohabitant by trees for which the cohabitant is out of bag
    Y.hat.cohab.oob <- as.vector(apply(cohabs, 1, function(x) mean((oobs %>% 
                                                                      filter(Train.Index == x[grep("Index$", names(cohabs))]))$Node.Prediction)))
    
    # return the mean squared difference between the cohabitant's true response value and the prediction generated by the trees for which the cohabitant is out of bag
    return(sum((cohabs$Observed.Response - Y.hat.cohab.oob) ^ 2) / n.oob.cohabs)
    
    # else return 0
  } else {
    return(0)
  }
}

######
# calculates MSPE1
# MSPE1's formula is similar to MSPE2's formula except we look at all training observations instead of only the out-of-bag cohabitants of the test observation
#
# oobs (dataframe): dataframe of tree index, terminal node index, training index, tree prediction, and true response value for all out-of-bag training observations
# Y.train (vector): response values of the training observations
# n.train (double): number of training observations
# RETURNS: a double that serves as a variance estimate, as well as the number of times a training observation was in bag for every tree
#
#####

get.mspe1 <- function(rf, df) {
  
  na.counter <- sum(is.na((rf$predicted-df[as.numeric(names(rf$predicted)), ncol(df)])^2))
  mspe1 <- rf$mse[length(rf$mse)]
  
  # return MSE3 and the NA counter
  return(c(mspe1, na.counter))
}